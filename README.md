# 여행친구 만들기 앱 만들기

## Backend : supabase

### 초기 Setting

`supabase init`

`supabase start`

`psql -h localhost -p 54322 -U postgres -d postgres`

### Script

#### Users

```
CREATE TABLE PUBLIC.USERS (
    ID UUID NOT NULL DEFAULT auth.uid(),
    EMAIL TEXT NOT NULL UNIQUE,
    USERNAME TEXT NULL UNIQUE,
    DESCRIPTION TEXT NOT NULL,
    SEX TEXT NOT NULL DEFAULT 'MALE',
    BORN_AT TIMESTAMP WITH TIME ZONE NOT NULL,
    CREATED_AT TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    CONSTRAINT USERS_PKEY PRIMARY KEY (ID),
    CONSTRAINT USERS_FKEY FOREIGN KEY (ID) 
    REFERENCES AUTH.USERS (ID) ON UPDATE CASCADE ON DELETE CASCADE
) TABLESPACE PG_DEFAULT;

ALTER TABLE PUBLIC.USERS ENABLE ROW LEVEL SECURITY;

CREATE POLICY "PERMIT SELECT TO AUTHENTICATED" 
ON PUBLIC.USERS FOR SELECT USING (TRUE);

CREATE POLICY "PERMIT INSERT OWN DATA TO AUTHENTICATED" 
ON PUBLIC.USERS FOR INSERT TO AUTHENTICATED 
WITH CHECK (AUTH.UID() = ID);

CREATE POLICY "PERMIT UPDATE OWN DATA TO AUTHENTICATED"  
ON PUBLIC.USERS FOR UPDATE TO AUTHENTICATED 
USING (AUTH.UID() = ID);

CREATE POLICY "PERMIT DELETE OWN DATA TO AUTHENTICATED"  
ON PUBLIC.USERS FOR DELETE TO AUTHENTICATED 
USING (AUTH.UID() = ID);

-- auth.users테이블에 insert가 발생하면(회원가입이 일어나면), users테이블에 insert
CREATE OR REPLACE FUNCTION PUBLIC.ON_SIGN_UP()
RETURNS TRIGGER
LANGUAGE PLPGSQL
SECURITY DEFINER SET SEARCH_PATH = PUBLIC
AS $$
    BEGIN
    INSERT INTO PUBLIC.USERS (
        ID,
        EMAIL, 
        USERNAME, 
        DESCRIPTION,
        SEX,
        BORN_AT
    )
    VALUES (
        COALESCE(NEW.ID, auth.uid()), 
        NEW.email,
        NEW.RAW_USER_META_DATA->>'username', 
        NEW.RAW_USER_META_DATA->>'description',
        COALESCE(NEW.RAW_USER_META_DATA->>'sex', 'MALE'),
        (NEW.RAW_USER_META_DATA->>'born_at')::TIMESTAMP WITH TIME ZONE
    );
    RETURN NEW;
    END;
$$;

CREATE TRIGGER ON_AUTH_USER_CREATED
AFTER INSERT ON AUTH.USERS
FOR EACH ROW EXECUTE PROCEDURE PUBLIC.ON_SIGN_UP();
```

### Trip Plan

```
CREATE TABLE PUBLIC.TRIP_PLAN (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    TITLE TEXT,
    CONTENT TEXT NULL,
    MIN_HEAD_COUNT INT CHECK (MIN_HEAD_COUNT >= 2) DEFAULT 2,
    MAX_HEAD_COUNT INT CHECK (MAX_HEAD_COUNT <= 8) DEFAULT 8,
    HASHTAGS TEXT[],
    COUNTRY_CODE TEXT,
    START_DATE TIMESTAMP NOT NULL,
    END_DATE TIMESTAMP NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CREATED_BY UUID NOT NULL DEFAULT AUTH.UID(),
    CONSTRAINT TRIP_PLAN_FKEY FOREIGN KEY (CREATED_BY) 
    REFERENCES PUBLIC.USERS(id) ON DELETE CASCADE
) TABLESPACE PG_DEFAULT;

CREATE FUNCTION FUNC_UPDATED_AT()
RETURNS TRIGGER AS $$
BEGIN
    NEW.UPDATED_AT = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TRIGGER_UPDATED_AT
BEFORE UPDATE ON PUBLIC.TRIP_PLAN
FOR EACH ROW
EXECUTE FUNCTION FUNC_UPDATED_AT();

ALTER TABLE PUBLIC.TRIP_PLAN ENABLE ROW LEVEL SECURITY;

CREATE POLICY "PERMIT SELECT TO AUTHENTICATED" 
ON PUBLIC.TRIP_PLAN FOR SELECT USING (TRUE);

CREATE POLICY "PERMIT INSERT OWN DATA TO AUTHENTICATED" 
ON PUBLIC.TRIP_PLAN FOR INSERT TO AUTHENTICATED 
WITH CHECK (AUTH.UID() = CREATED_BY);

CREATE POLICY "PERMIT UPDATE OWN DATA TO AUTHENTICATED"  
ON PUBLIC.TRIP_PLAN FOR UPDATE TO AUTHENTICATED 
USING (AUTH.UID() = CREATED_BY);

CREATE POLICY "PERMIT DELETE OWN DATA TO AUTHENTICATED"  
ON PUBLIC.TRIP_PLAN FOR DELETE TO AUTHENTICATED 
USING (AUTH.UID() = CREATED_BY);
```

### Trip Apply
```
CREATE TABLE PUBLIC.JOIN_APPLY (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    TRIP_PLAN_ID UUID,
    CONTENT TEXT NULL,
    IS_ACCEPTED BOOL NOT NULL DEFAULT FALSE,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CREATED_BY UUID NOT NULL DEFAULT AUTH.UID(),
    CONSTRAINT JOIN_APPLY_FKEY1 FOREIGN KEY (TRIP_PLAN_ID) 
    REFERENCES PUBLIC.TRIP_PLAN(id) ON DELETE CASCADE,
    CONSTRAINT JOIN_APPLY_FKEY2 FOREIGN KEY (CREATED_BY) 
    REFERENCES PUBLIC.USERS(id) ON DELETE CASCADE,
    UNIQUE (TRIP_PLAN_ID, CREATED_BY)
) TABLESPACE PG_DEFAULT;

CREATE TRIGGER TRIGGER_UPDATED_AT
BEFORE UPDATE ON PUBLIC.JOIN_APPLY
FOR EACH ROW
EXECUTE FUNCTION FUNC_UPDATED_AT();

ALTER TABLE PUBLIC.JOIN_APPLY ENABLE ROW LEVEL SECURITY;

CREATE POLICY "PERMIT SELECT TO AUTHENTICATED" 
ON PUBLIC.JOIN_APPLY FOR SELECT USING (TRUE);

CREATE POLICY "PERMIT INSERT OWN DATA TO AUTHENTICATED" 
ON PUBLIC.JOIN_APPLY FOR INSERT TO AUTHENTICATED 
WITH CHECK (AUTH.UID() = CREATED_BY);

CREATE POLICY "PERMIT UPDATE OWN DATA TO AUTHENTICATED"  
ON PUBLIC.JOIN_APPLY FOR UPDATE TO AUTHENTICATED 
USING (AUTH.UID() = CREATED_BY);

CREATE POLICY "PERMIT DELETE OWN DATA TO AUTHENTICATED"  
ON PUBLIC.JOIN_APPLY FOR DELETE TO AUTHENTICATED 
USING (AUTH.UID() = CREATED_BY);

CREATE OR REPLACE FUNCTION PUBLIC.CREATE_OWN_JOIN_APPLY()
RETURNS TRIGGER
LANGUAGE PLPGSQL
SECURITY DEFINER SET SEARCH_PATH = PUBLIC
AS $$
    BEGIN
    INSERT INTO PUBLIC.JOIN_APPLY (
        TRIP_PLAN_ID,
        CONTENT, 
        IS_ACCEPTED
    )
    VALUES (
        NEW.ID, 
        'Trip Plan Created',
        TRUE
    );
    RETURN NEW;
    END;
$$;

CREATE TRIGGER ON_CREATE_TRIP_PLAN
AFTER INSERT ON PUBLIC.TRIP_PLAN
FOR EACH ROW EXECUTE PROCEDURE PUBLIC.CREATE_OWN_JOIN_APPLY();
```